use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Turn type classification for LLM-generated summaries
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TurnType {
    /// User requesting a specific task to be done
    Task,
    /// User asking a question
    Question,
    /// User reporting or trying to fix an error
    ErrorFix,
    /// User clarifying a previous request
    Clarification,
    /// General discussion without specific task
    Discussion,
}

impl std::fmt::Display for TurnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TurnType::Task => write!(f, "task"),
            TurnType::Question => write!(f, "question"),
            TurnType::ErrorFix => write!(f, "error_fix"),
            TurnType::Clarification => write!(f, "clarification"),
            TurnType::Discussion => write!(f, "discussion"),
        }
    }
}

impl std::str::FromStr for TurnType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "task" => Ok(TurnType::Task),
            "question" => Ok(TurnType::Question),
            "error_fix" => Ok(TurnType::ErrorFix),
            "clarification" => Ok(TurnType::Clarification),
            "discussion" => Ok(TurnType::Discussion),
            _ => Err(format!("Unknown turn type: {s}")),
        }
    }
}

/// LLM-generated summary for a detected turn
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TurnSummary {
    pub id: Uuid,
    pub turn_id: Uuid, // FK to detected_turns.id

    // LLM-generated content
    pub user_intent: String,      // "User wanted to add JWT authentication"
    pub assistant_action: String, // "Created auth module with JWT support"
    pub summary: String,          // Combined summary sentence

    // Classification
    pub turn_type: Option<TurnType>,
    pub complexity_score: Option<f64>, // 0.0 - 1.0

    // Generation metadata
    pub model_used: Option<String>,
    pub prompt_version: i32,
    pub generated_at: DateTime<Utc>,
}

impl TurnSummary {
    pub fn new(turn_id: Uuid, user_intent: String, assistant_action: String) -> Self {
        let summary = format!("{user_intent} {assistant_action}");
        Self {
            id: Uuid::new_v4(),
            turn_id,
            user_intent,
            assistant_action,
            summary,
            turn_type: None,
            complexity_score: None,
            model_used: None,
            prompt_version: 1,
            generated_at: Utc::now(),
        }
    }

    /// Builder method: set summary (override auto-generated)
    pub fn with_summary(mut self, summary: String) -> Self {
        self.summary = summary;
        self
    }

    /// Builder method: set turn type
    pub fn with_turn_type(mut self, turn_type: TurnType) -> Self {
        self.turn_type = Some(turn_type);
        self
    }

    /// Builder method: set complexity score
    pub fn with_complexity(mut self, score: f64) -> Self {
        self.complexity_score = Some(score.clamp(0.0, 1.0));
        self
    }

    /// Builder method: set model metadata
    pub fn with_model(mut self, model: String, prompt_version: i32) -> Self {
        self.model_used = Some(model);
        self.prompt_version = prompt_version;
        self
    }

    /// Check if this summary was generated by an LLM
    pub fn is_llm_generated(&self) -> bool {
        self.model_used.is_some()
    }

    /// Check if this is a high-complexity turn
    pub fn is_high_complexity(&self) -> bool {
        self.complexity_score.is_some_and(|s| s > 0.7)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_turn_summary() {
        let turn_id = Uuid::new_v4();
        let summary = TurnSummary::new(
            turn_id,
            "User wanted to add authentication".to_string(),
            "Created auth module".to_string(),
        );

        assert_eq!(summary.turn_id, turn_id);
        assert!(summary.summary.contains("authentication"));
        assert!(summary.summary.contains("auth module"));
        assert!(!summary.is_llm_generated());
    }

    #[test]
    fn test_turn_type_display() {
        assert_eq!(TurnType::Task.to_string(), "task");
        assert_eq!(TurnType::Question.to_string(), "question");
        assert_eq!(TurnType::ErrorFix.to_string(), "error_fix");
    }

    #[test]
    fn test_turn_type_from_str() {
        assert_eq!("task".parse::<TurnType>().unwrap(), TurnType::Task);
        assert_eq!("QUESTION".parse::<TurnType>().unwrap(), TurnType::Question);
        assert_eq!("error_fix".parse::<TurnType>().unwrap(), TurnType::ErrorFix);
        assert!("invalid".parse::<TurnType>().is_err());
    }

    #[test]
    fn test_complexity_clamping() {
        let turn_id = Uuid::new_v4();
        let summary = TurnSummary::new(turn_id, "intent".to_string(), "action".to_string())
            .with_complexity(1.5); // Should be clamped to 1.0

        assert_eq!(summary.complexity_score, Some(1.0));

        let summary2 = TurnSummary::new(turn_id, "intent".to_string(), "action".to_string())
            .with_complexity(-0.5); // Should be clamped to 0.0

        assert_eq!(summary2.complexity_score, Some(0.0));
    }

    #[test]
    fn test_is_high_complexity() {
        let turn_id = Uuid::new_v4();

        let low_complexity =
            TurnSummary::new(turn_id, "i".to_string(), "a".to_string()).with_complexity(0.3);
        let high_complexity =
            TurnSummary::new(turn_id, "i".to_string(), "a".to_string()).with_complexity(0.9);
        let no_complexity = TurnSummary::new(turn_id, "i".to_string(), "a".to_string());

        assert!(!low_complexity.is_high_complexity());
        assert!(high_complexity.is_high_complexity());
        assert!(!no_complexity.is_high_complexity());
    }

    #[test]
    fn test_with_model() {
        let turn_id = Uuid::new_v4();
        let summary = TurnSummary::new(turn_id, "i".to_string(), "a".to_string())
            .with_model("gemini-1.5-flash".to_string(), 2);

        assert!(summary.is_llm_generated());
        assert_eq!(summary.model_used, Some("gemini-1.5-flash".to_string()));
        assert_eq!(summary.prompt_version, 2);
    }
}
